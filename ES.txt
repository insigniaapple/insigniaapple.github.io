根据数据范围反推解题方法
			
 n <= 30 , 指数级别, dfs+剪枝，状态压缩dp
 
 n <= 100  =>  O(n^3) ，floyd，dp，高斯消元
 
 n <= 1000  =>  O(n^2) ， O(n^2logn) ，dp，二分，朴素版Dijkstra、朴素版Prim、Bellman-Ford
 
 n <= 10000  =>  O(n * \sqrt n) ，块状链表、分块、莫队
 
 n <= 100000  =>  O(nlogn)  =>各种sort，线段树、树状数组、set/map、heap、拓扑排序、dijkstra+heap、prim+heap、spfa、求凸包、求半平面交、二分、CDQ分治、整体二分
 
 n <= 1000000  =>  O(n) , 以及常数较小的  O(nlogn)  算法 => 单调队列、 hash、双指针扫描、并查集，kmp、AC自动机，常数比较小的  O(nlogn)  的做法：sort、树状数组、heap、dijkstra、spfa
 
 n <= 10000000  =>  O(n) ，双指针扫描、kmp、AC自动机、线性筛素数
 
 n <= 10^9  =>  O(\sqrt n) ，判断质数
 
 n <= 10^{18}  =>  O(logn) ，最大公约数，快速幂
 
 n <= 10^{1000}  =>  O((logn)^2) ，高精度加减乘除
 
 n <= 10^{100000}  =>  O(logk \times loglogk)，k表示位数 ，高精度加减、FFT/NTT

最长公共子序列

        int len_a=a.size(),len_b=b.size(); 
		for(int i=0;i<len_a;i++)
		{
			for(int j=0;j<len_b;j++)
			{
				if(a.at(i)==b.at(j))
					dp[i+1][j+1]=dp[i][j]+1;
				else 
					dp[i+1][j+1]=max(dp[i+1][j],dp[i][j+1]);
			}
		}
		return dp[len_a][len_b];


z函数
vector<int> z_function(string s) {
  int n = (int)s.length();
  vector<int> z(n);
  for (int i = 1, l = 0, r = 0; i < n; ++i) {
    if (i <= r && z[i - l] < r - i + 1) {
      z[i] = z[i - l];
    } else {
      z[i] = max(0, r - i + 1);
      while (i + z[i] < n && s[z[i]] == s[i + z[i]]) ++z[i];
    }
    if (i + z[i] - 1 > r) l = i, r = i + z[i] - 1;
  }
  return z;
}


归并排序(不具备传递性)
stable_sort(v.begin(),v.end(),compare); 
 
约数和
ll sum(ll p,ll k)
{
	if(k==0) return 1;
	if(k&1) return sum(p,k/2)%mod*(1+ pow(p,(k+1)>>1))%mod; //pow to ksm
	
	return (1 + sum(p,k-1)%mod)%mod;
}

ll Nsum(ll n)
{
    ll res = 1;
	for(int i =2 ;i<=n ;i++)
	{
	    ll s = 0;
		while(n%i==0)
		{
			s++;
			n/=i;
		}
		if(s) res*=sum(i,s+1);
	}
	return res;
}
 
斐波那契数学公式

int climbStairs(int n) {
	double sqrt5 = sqrt(5);
	double fibn = pow((1 + sqrt5) / 2, n + 1) - pow((1 - sqrt5) / 2, n + 1);
	return (int)round(fibn / sqrt5);
}


 
拓扑排序

dfs 
vector<vector<int>> edges;
vector<int> visited;
bool valid = true;
    void dfs(int u) {
        visited[u] = 1;
        for (int v: edges[u]) {
            if (visited[v] == 0) {
                dfs(v);
                if (!valid) {
                    return;
                }
            }
            else if (visited[v] == 1) {
                valid = false;
                return;
            }
        }
        visited[u] = 2;
    }

    bool canFinish(int numCourses, vector<vector<int>>& prerequisites) {
        edges.resize(numCourses);
        visited.resize(numCourses);
        for (const auto& info: prerequisites) {
            edges[info[1]].push_back(info[0]);
        }
        for (int i = 0; i < numCourses && valid; ++i) {
            if (!visited[i]) {
                dfs(i);
            }
        }
        return valid;
    }
};

bfs 
vector<vector<int>> edges;
vector<int> indeg;
    bool canFinish(int numCourses, vector<vector<int>>& prerequisites) {
        edges.resize(numCourses);
        indeg.resize(numCourses);
        for (const auto& info: prerequisites) {
            edges[info[1]].push_back(info[0]);
            ++indeg[info[0]];
        }

        queue<int> q;
        for (int i = 0; i < numCourses; ++i) {
            if (indeg[i] == 0) {
                q.push(i);
            }
        }

        int visited = 0;
        while (!q.empty()) {
            ++visited;
            int u = q.front();
            q.pop();
            for (int v: edges[u]) {
                --indeg[v];
                if (indeg[v] == 0) {
                    q.push(v);
                }
            }
        }

        return visited == numCourses;
    }
};





字符串拼接
	stringstream
	清空
	sstream.str("");
	字符串
	sstream.str();



数组的最大公约数

//maxgysarray求一个数组的最大公约数，要求的参量为数组a及其大小num
int gcdv(int a[],int num)
{
	int max;
	max=__gcd(a[0],a[1]);
	for(int i=1;i<=num-1;i++) max=__gcd(max,a[i]);
	return max;
}

大写字母
	toupper();

全排列函数
	next_permutation(nums.begin(),nums.end())；

拔山盖世算法(求解a^x=b(modP))
int BSGS(int a, int b, int P) {
	int t = sqrt(P) + 1; mp.clear(); b %= P;
	for (int j = 0, s = b; j < t; j++) 
		mp[s] = j, s = (LL)s * a % P;
	a = power(a, t, P);
	for (int i = 1, s = 1; i <= t; i++) {
		s = (LL)s * a % P;
		if (mp.count(s) && i * t - mp[s] >= 0)
			return i * t - mp[s];
	}
	return -1;
}

滑动窗口
	int lengthOfLongestSubstring(string s){
    int i, j = 0, count = 0, max = 0, index[128] = {0}, start = 0;
    for(i=0;s[i]!='\0';i++)     
    {
        if(index[s[i]]>start)   //index用来储存出现重复字符时
        {                       //子串起始下标应移动到的地方
            count = i-start;
            if(count>max)
            {
                max = count;
            }
            start = index[s[i]];
        }
        index[s[i]] = i+1;
    }
    count = i-start;
    return count>max?count:max;
	}

迭代器前移后移prev() next() 默认为1，负值为相反方向
    template <class T>
    T prev (T it, typename iterator_traits<T>::difference_type n = 1);
	

HV输入模板

#include<bits/stdc++.h>
using namespace std;
#define fi first
#define se second
#define mp make_pair
#define pb push_back
#define in(x) scanf("%d", &x)
#define lin(x) scanf("%lld", &(x));
#define For(i, a, b) for(int i=(a); i<=(b); i++)
#define For(i,a) for(int i=0; i<(a);i++)
#define Frr(i, a, b) for(int i=(b); i>=(a); i--)
#define sz(a) (int)a.size()
#define all(a) a.begin(), a.end()
#define pw(x) (1ll<<(x))
#define nl "\n"
typedef long long ll;
typedef pair<int, int> pii;
typedef vector<int> vi;
typedef double db;
const int N = 1000010;

int read()
{
    int sSs,Kk = 1;char S;
    while(S = getchar(),S<'0'||S>'0') if(S=='-') Kk = -1; sSs = S-'0';
    while(S = getchar(),S>='0'&&S<='9') sSs = sSs*10 +S-'0';
    return Kk*sSs;

}

ll m,n,T,t,a[N];
int main(){
    ios::sync_with_stdio(false),cin.tie(0),cout.tie(0);
    #ifdef LOCAL
        freopen("F:\\VSCode\\1.in", "r", stdin);
        freopen("F:\\VSCode\\1.out", "w", stdout);
    #endif
    rep(i,1,10) cout<<(i&-i)<<'\n';
    

}

RMQ
	const int N = 200010,M = 18;
	int a[N];
	int n,m;
	int f[N][M];

	int main(){
		cin>>n;
		for(int i = 1;i<=n;i++)cin>>a[i];

		for(int j = 0;j<M;j++){
			for(int i = 1;i+(1<<j)-1<=n;i++)
				if(!j)f[i][j] = a[i];
				else f[i][j] = max(f[i][j-1],f[i+(1<<j-1)][j-1]);
		}


		cin>>m;
		while(m--){
			int l,r;
			cin>>l>>r;
			int len = r-l+1;
			int k = log(len)/log(2);
			cout<< max(f[l][k],f[r-(1<<k)+1][k])<<endl;;
		}
		return 0;
	}
	
树状数组
using LL = long long;
struct BIT{
    int n;
    vector<LL> v;
    BIT(int n) : n(n), v(n){
    }
    void add(int x, LL y) {
        for (x += 1; x <= n; x += x & -x) v[x - 1] += y;
    }
    LL sum(int x) {
        LL res = 0;
        for (x += 1; x; x -= x & -x) res += v[x - 1];
        return res;
    }
};
class Solution {
public:
    long long goodTriplets(vector<int>& nums1, vector<int>& nums2) {
        int n = nums1.size();
        vector<int> p(n), a(n);
        for (int i = 0; i < n; i += 1) p[nums1[i]] = i;
        for (int i = 0; i < n; i += 1) a[i] = p[nums2[i]];
        vector<LL> bit(n);
        BIT s(n), s2(n);
        LL ans = 0;
        for (int i = 0; i < n; i += 1) {
            ans += s2.sum(a[i]);
            s2.add(a[i], s.sum(a[i]));
            s.add(a[i], 1);
        }
        return ans;
    }
};

二分图匹配


传说在遥远的地方有一个非常富裕的村落,有一天,村长决定进行制度改革：重新分配房子。
这可是一件大事,关系到人民的住房问题啊。村里共有n间房间,刚好有n家老百姓,考虑到每家都要有房住（如果有老百姓没房子住的话，容易引起不安定因素），每家必须分配到一间房子且只能得到一间房子。
另一方面,村长和另外的村领导希望得到最大的效益,这样村里的机构才会有钱.由于老百姓都比较富裕,他们都能对每一间房子在他们的经济范围内出一定的价格,比如有3间房子,一家老百姓可以对第一间出10万,对第2间出2万,对第3间出20万.(当然是在他们的经济范围内).现在这个问题就是村领导怎样分配房子才能使收入最大.(村民即使有钱购买一间房子但不一定能买到,要看村领导分配的).

输入数据包含多组测试用例，每组数据的第一行输入n,表示房子的数量(也是老百姓家的数量)，接下来有n行,每行n个数表示第i个村名对第j间房出的价格(n<=300)。

请对每组数据输出最大的收入值，每组的输出占一行。

 2 #include<stdio.h>
 3 #include<string.h>
 4 #define INF 99999999
 5 #define maxn 303
 6 int map[maxn][maxn],match[maxn],visl[maxn],visr[maxn],pr[maxn],pl[maxn],slack[maxn];
 7 int n,m;
 8 int dfs(int u)
 9 {
10     int i,j,val;
11     visl[u]=1;
12     for(i=1;i<=n;i++)
13     {
14         if(!visr[i])
15         {
16             val=pl[u]+pr[i]-map[u][i];
17             if(val==0)
18             {
19                 visr[i]=1;
20                 if(match[i]==-1||dfs(match[i]))
21                 {
22                     match[i]=u;
23                     return 1;
24                 }
25             }
26             if(val>0&&val<slack[i])
27                 slack[i]=val;
28         }
29     }
30     return 0;
31 }
32 int km()
33 {
34     int i,j,res,d;
35     res=0;
36     memset(pr,0,sizeof(pr));
37     for(i=1;i<=n;i++)
38         pl[i]=INF;
39     memset(match,-1,sizeof(match));
40     for(i=1;i<=n;i++)
41     {
42         for(j=1;j<=n;j++)
43             slack[j]=INF;
44         while(1)
45         {
46             memset(visl,0,sizeof(visl));
47             memset(visr,0,sizeof(visr));
48             if(dfs(i))break;
49             d=INF;
50             for(j=1;j<=n;j++)
51             {
52                 if(!visr[j]&&d>slack[j])
53                     d=slack[j];
54             }
55             for(j=1;j<=n;j++)
56             {
57                 if(visr[j])
58                     pr[j]+=d;
59                 if(visl[j])
60                     pl[j]-=d;
61             }
62         }
63     }
64     for(i=1;i<=n;i++)
65         res+=map[match[i]][i];
66     return res;
67 }
68 int main()
69 {
70     int i,j;
71     while(scanf("%d",&n)!=EOF)
72     {
73         for(i=0;i<=n;i++)
74             for(j=0;j<=n;j++)
75             {
76                 if(i==j)map[i][j]=0;
77                 else map[i][j]=INF;
78             }
79         for(i=1;i<=n;i++)
80         {
81             for(j=1;j<=n;j++)
82             {
83                 int z;
84                 scanf("%d",&z);
85                 map[i][j]=z;
86             }
87         }
88         int ans=km();
89         printf("%d\n",ans);
90     }
91 }

最大公约数

int gcd(int a,int b)
{
	return b ? gcd(b,a%b):a;

前n个数的异或值
   unsigned xor_n(unsigned n)
{

 unsigned t = n & 3;

 if (t & 1) return t / 2u ^ 1;

 return t / 2u ^ n;

}



二进制
    __builtin_popcount(i) 二进制里有多少个1

结构体快速排序
    struct node {
		int l,r,val;
		bool operator < (const node &t) {
			return r < t.r || (r == t.r && l > t.l);
		}
    } a[2 * N];
	sort(a,a+n);

数状树状
online int lowbit(x){return x&(-x);}

void update(int x,int y,int n){
    for(int i=x;i<=n;i+=lowbit(i))    //x为更新的位置,y为更新后的数,n为数组最大值
        c[i] += y;
}

int getsum(int x){
    int ans = 0;
    for(int i=x;i;i-=lowbit(i))
        ans += c[i];
    return ans;
}

getsum(y)-getsum(x-1)


线段树_单点修改
const int N = 500010;
#define int long long
int a[N];
int n,m;
struct tr{
    int l,r;
    int sum,v;
}t[4*N];

inline int gcd(int a,int b){
    return b?gcd(b,a%b):a;
}

inline void pushup(tr &u,tr &l,tr &r)
{
    u.sum = l.sum+r.sum;
    u.v = gcd(l.v,r.v);
}

void pushup(int u){
    pushup(t[u],t[u<<1],t[u<<1|1]);
}

void build(int u,int l,int r)
{
    t[u] = {l,r};
    if(l==r)
        t[u] = {l,r,a[r]-a[r-1], a[r]-a[r-1]};
    else{
        int mid = l+r >> 1;
        build(u<<1, l, mid);
        build(u<<1|1, mid+1, r);
        pushup(u);
    }
}
tr query(int u,int l,int r){
    if(t[u].l>=l&&t[u].r<=r) return t[u];
    else{
        int mid = t[u].r+t[u].l>>1;
        if(r<=mid) return query(u<<1,l,r);
        else if(l>mid) return query(u<<1|1,l,r);
        else
        {
            auto left = query(u << 1, l, r);
            auto right = query(u << 1 | 1, l, r);
            tr res;
            pushup(res, left, right);
            return res;
        }
        
    }
}

void modify(int u,int p,int x)
{
    if(t[u].r==p&&t[u].l==p) {
        int b = t[u].sum+x;
        t[u] = {p,p,b,b};
    }
    else
    {
        int mid = t[u].r+t[u].l>>1;
        
        if(p<=mid) modify(u<<1,p,x);
        else modify(u<<1|1,p,x);
        pushup(u);
    }
}


signed main()
{
    scanf("%lld%lld", &n, &m);
    for (int i = 1; i <= n; i ++ ) scanf("%lld", &a[i]);
    build(1, 1, n);

    int l, r;
    int d;
    char op[2];
    while (m -- )
    {
        scanf("%s%lld%lld", op, &l, &r);
        if (*op == 'Q')
        {
            auto left = query(1, 1, l);
            tr right({0, 0, 0, 0});
            if (l + 1 <= r) right = query(1, l + 1, r);
            printf("%lld\n", abs(gcd(left.sum, right.v)));
        }
        else
        {
            scanf("%lld", &d);
            modify(1, l, d);
            if (r + 1 <= n) modify(1, r + 1, -d);
        }
    }

}




线段树(区间求和加k);    
    #include <iostream>
	typedef long long LL;
	LL n, a[100005], d[270000], b[270000];
	void build(LL l, LL r, LL p) {  // l:区间左端点 r:区间右端点 p:节点标号
	  if (l == r) {
		d[p] = a[l];  //将节点赋值
		return;
	  }
	  LL m = l + ((r - l) >> 1);
	  build(l, m, p << 1), build(m + 1, r, (p << 1) | 1);  //分别建立子树
	  d[p] = d[p << 1] + d[(p << 1) | 1];
	}
	void update(LL l, LL r, LL c, LL s, LL t, LL p) {
	  if (l <= s && t <= r) {
		d[p] += (t - s + 1) * c, b[p] += c;  //如果区间被包含了，直接得出答案
		return;
	  }
	  LL m = s + ((t - s) >> 1);
	  if (b[p])
		d[p << 1] += b[p] * (m - s + 1), d[(p << 1) | 1] += b[p] * (t - m),
			b[p << 1] += b[p], b[(p << 1) | 1] += b[p];
	  b[p] = 0;
	  if (l <= m)
		update(l, r, c, s, m, p << 1);  //本行和下面的一行用来更新p*2和p*2+1的节点
	  if (r > m) update(l, r, c, m + 1, t, (p << 1) | 1);
	  d[p] = d[p << 1] + d[(p << 1) | 1];  //懒标记相加
	}
	LL getsum(LL l, LL r, LL s, LL t, LL p) {    //x,y,1,n,1;
	  if (l <= s && t <= r) return d[p];
	  LL m = s + ((t - s) >> 1);
	  if (b[p])
		d[p << 1] += b[p] * (m - s + 1), d[(p << 1) | 1] += b[p] * (t - m),
			b[p << 1] += b[p], b[(p << 1) | 1] += b[p];
	  b[p] = 0;
	  LL sum = 0;
	  if (l <= m)
		sum =
			getsum(l, r, s, m, p << 1);  //本行和下面的一行用来更新p*2和p*2+1的答案
	  if (r > m) sum += getsum(l, r, m + 1, t, (p << 1) | 1);
	  return sum;
	}
	int main() {
	  std::ios::sync_with_stdio(0);
	  LL q, i1, i2, i3, i4;
	  std::cin >> n >> q;
	  for (LL i = 1; i <= n; i++) std::cin >> a[i];
	  build(1, n, 1);
	  while (q--) {
		std::cin >> i1 >> i2 >> i3;
		if (i1 == 2)
		  std::cout << getsum(i2, i3, 1, n, 1) << std::endl;  //直接调用操作函数
		else
		  std::cin >> i4, update(i2, i3, i4, 1, n, 1);
	  }
	  return 0;
	}

线筛法
	void init() {
	  phi[1] = 1;
	  for (int i = 2; i < MAXN; ++i) {
		if (!vis[i]) {
		  phi[i] = i - 1;
		  pri[cnt++] = i;
		}
		for (int j = 0; j < cnt; ++j) {
		  if (1ll * i * pri[j] >= MAXN) break;
		  vis[i * pri[j]] = 1;
		  if (i % pri[j]) {
			phi[i * pri[j]] = phi[i] * (pri[j] - 1);
		  } else {
			// i % pri[j] == 0
			// 换言之，i 之前被 pri[j] 筛过了
			// 由于 pri 里面质数是从小到大的，所以 i 乘上其他的质数的结果一定也是
			// pri[j] 的倍数 它们都被筛过了，就不需要再筛了，所以这里直接 break
			// 掉就好了
			phi[i * pri[j]] = phi[i] * pri[j];
			break;
		  }
		}
	  }
	}
最小生成树
prim算法
	#include<bits/stdc++.h>
	using namespace std;
	const int maxn=5005;
	int t,n,sum,m;
	long long pow(long long c)
	{
		return c*c;
	}
	long long x[5005],y[5005],g[5005][5005];
	const int N = 5005, INF = 0x3f3f3f3f;
	long long dist[N];
	//邻接矩阵存储所有边
	//dist存储其他点到S的距离
	bool st[N];//开始初始化为false

	long long prim() 
	{
		//如果图不连通返回INF, 否则返回res
		memset(dist, 0x3f, sizeof dist);
		memset(st , 0, sizeof st);
		long long res = 0;
		for(int i = 0; i < n; i++)
		{
			int t = -1;
			for(int j = 1; j <= n; j++) 
				if(!st[j] && (t == -1 || dist[t] > dist[j]))//j不在集合中&&（t==-1||
					t = j;
					
			//寻找离集合S最近的点        
			if(i && dist[t] ==INF) return INF;
			
			
			//判断是否连通，有无最小生成树,排除负环
			if(i) res =max(res, dist[t]);
			
			st[t] = true;
			
			//更新最新S的权值和
			for(int j = 1; j <= n; j++) dist[j] = min(dist[j], g[t][j]);
		}

		return res;
	}


	int main(){
		ios::sync_with_stdio(false),cin.tie(0),cout.tie(0);
		#ifdef LOCAL
			freopen("F:\\VSCode\\1.in", "r", stdin);
			freopen("F:\\VSCode\\1.out", "w", stdout);
		#endif
		cin>>t;
		while(t--)
		{
			cin>>n;
			for(int i=1;i<=n;i++) cin>>x[i]>>y[i];

			for(int i = 1; i <= n; i++)
			for(int j = 1; j <= n; j++)
				if(i ==j) g[i][j] = 0;
				else g[i][j] = INF;
			for(int i=1;i<=n;i++)
			for(int j=i+1;j<=n;j++){
				g[i][j] =g[j][i]= pow(x[i]-x[j])+pow(y[i]-y[j]);
			}
		
			cout<<prim()<<'\n';
		}
		
	   return 0;
	}
Kruskal算法
	#include<iostream>
	#include<algorithm>
	#include<cstring>

	using namespace std;

	const int N=200010,M=100010;         

	int p[M];
	int n,m;

	//按w进行排序
	vector<pii>
	sort(vtMap.begin(), vtMap.end(), 
        [](const pair<int, int> &x, const pair<int, int> &y) -> int {
        return x.second > y.second;
    });
	
	struct Edge
	{
		int a,b,w;
		 bool operator< (const Edge &W)const
		{
			return w < W.w;
		}
	}edges[N];


	//并查集
	int find(int x)
	{
		if(p[x]!=x) p[x]=find(p[x]);
		else return x;
	} 

	int Kruskal()
	{
		//res记录最小生成树的树边权重之和,cnt记录的是全部加入到树的集合中边的数量(可能有多个集合)
		int res=0,cnt=0;
		for(int i=0;i<m;i++)
		{
			//大小排序，但是点的位置可能相差较远，会有产生多个集合
			int a=edges[i].a,b=edges[i].b,w=edges[i].w;
			if(find(a)!=find(b))
			/*
			具体可以参考连通块中点的数量,如果a和b已经在一个集合当中了,说明这两个点已经被一种方式连接起来了,
			如果加入a-b这条边,会导致集合中有环的生成,而树中不允许有环生成,所以一个连通块中的点的数量假设
			为x,那么里面x个节点应该是被串联起来的,有x-1条边
			*/
			{
				p[find(a)]=p[find(b)];  //将a,b所在的两个集合连接起来
				cnt++;                  //因为加入的是a-b的这一条边,将a,b所在的两个集合连接之后,全部集合中的边数加1
				res+=w;
			}//加入到集合中的边的权重之和
		}

		if(cnt==n-1) return res;        //可以生成最小生成树
		else return 0x3f3f3f3f;         //树中有n个节点便有n-1条边,如果cnt不等于n-1的话,说明无法生成有n个节点的树
	}



	int main()
	{
		cin>>n>>m;

		for(int i=0;i<n;i++) p[i]=i;//初始化并查集

		for(int i=0;i<m;i++)
		{
			int a,b,w;
			scanf("%d%d%d",&a,&b,&w);
			edges[i]={a,b,w};
		}

		sort(edges,edges+m);//将边的权重按照大小一一排序

		int t=Kruskal();

		if(t==0x3f3f3f3f) printf("impossible\n");
		else printf("%d\n",t);

		return 0;
	}


枚举优化
    改变/减少枚举变量
	缩小枚举范围
	二分 ：二分查找、二分搜索非常有效，一般是复杂度从O(N)降到O(logN)，使用范围也很广
	哈希：Hash，空间换时间
	双指针：Leetcode上对应的分类是two pointer，直译过来就是双指针，大概的思想就是滑动窗口
	前缀、后缀和：空间换时间
求质数
    for(int i=0;i<=N;i++) p[i] =1;
    p[1] = 0; 
    for(int i=2;i<=N;i++){
        if(p[i]){
            for(int j=2*i;j<=N;j+=i) p[j]=0;//剔除倍数
        }
    }
	
	
	int isPrime(int n)
	{	//返回1表示判断为质数，0为非质数，在此没有进行输入异常检测
		float n_sqrt;
		if(n==2 || n==3) return 1;
		if(n%6!=1 && n%6!=5) return 0;
		n_sqrt=floor(sqrt((float)n));
		for(int i=5;i<=n_sqrt;i+=6)
		{
			if(n%(i)==0 | n%(i+2)==0) return 0;
		}
			return 1;
	}


并查集
	int find(int x) {
		if (f[x] != x) {
			f[x] = find(f[x]);
		}
		return f[x];
	}

	void merge(int x, int y) {
		x = find(x);
		y = find(y);
		if (x != y) {
			f[x] = y;
		}
	}
平方、立方阶和
    n(n+1)(2n+1)/6
    [n(n+1)/2]^2
128位整数
    __int128_t

求最小
    min({a,b,c})

二维差分
	int main(){
		cin>>n>>r;
		mx = my =r;
		while(n--){
			cin >> x >> y >> t;
			x++;y++;
			w[x][y] = t;
			mx = max(mx,x),
			my = max(my,y);
		}
		
		for (int i = 1; i <= mx; i ++ )
		for (int j = 1; j <= my; j ++ )
		w[i][j] +=w[i][j-1]+w[i-1][j]-w[i-1][j-1];
		s = 0;
		for (int i = r; i <= mx; i ++ )
		for (int j = r; j <= my; j ++ )
		s = max(s,w[i][j]-w[i-r][j]-w[i][j-r]+w[i-r][j-r]);
		
		cout << s ;
		
		return 0;
	}

KMP算法
	int strStr(string haystack, string needle) {
        int n = haystack.size(), m = needle.size();
        if (m == 0) {
            return 0;
        }
        vector<int> pi(m);
        for (int i = 1, j = 0; i < m; i++) {
            while (j > 0 && needle[i] != needle[j]) {
                j = pi[j - 1];
            }
            if (needle[i] == needle[j]) {
                j++;
            }
            pi[i] = j;
        }
        for (int i = 0, j = 0; i < n; i++) {
            while (j > 0 && haystack[i] != needle[j]) {
                j = pi[j - 1];
            }
            if (haystack[i] == needle[j]) {
                j++;
            }
            if (j == m) {
                return i - m + 1;
            }
        }
        return -1;
    }

sunday算法
    
	int indexShift(const string s,const char ch) {
		for (int k1(0); k1 < s.length(); ++k1) {
			if (ch == s[k1]) return -k1;
		}
		return 1;
	}

	int sunday(const string s1, const string s2) {
		int ret=0;
		int sl1(s1.length()), sl2(s2.length());
		if (!(sl1 && sl2))return ret;
		for (int k1(0), k2(0); k1 <= sl1 - sl2;) {
			if (s1[k1] == s2[k2]) ++k1, ++k2;
			else {
				k1 += sl2 - k2;
				k1 += k1 < sl1 ? indexShift(s2, s1[k1]) : 0;
				k2 = 0;
			}
			if (k2 == sl2) ret++, k1 -= k2 - 1, k2 = 0;
		}
		return ret;
	}


快速幂
    LL qmi(int a, int b)
	{
		LL res = 1 % p;
		while (b)
		{
			if (b & 1) res = res * a % p;
			a = a * (LL)a % p;
			b >>= 1;
		}
		return res;
	}
	
	int quickPower(int a, int b)//是求a的b次方
	{
		int ans = 1, base = a;//ans为答案，base为a^(2^n)
		while(b > 0)//b是一个变化的二进制数，如果还没有用完
		{
			if(b & 1)//&是位运算，b&1表示b在二进制下最后一位是不是1，如果是：
				ans *= base;//把ans乘上对应的a^(2^n)
			
			base *= base;//base自乘，由a^(2^n)变成a^(2^(n+1))
			b>>=1;//位运算，b右移一位，如101变成10（把最右边的1移掉了），10010变成1001。现在b在二进制下最后一位是刚刚的倒数第二位。结合上面b & 1食用更佳
		}
		return ans;
	}

本地输入输出模板
    freopen("F:\\VSCode\\1.in", "r", stdin);
    freopen("F:\\VSCode\\1.out", "w", stdout);  //"a",加写，不是重写

最后一个换行
     for (int i = 0; i < n; i++) {
        std::cout << cnt[b[i]]-- << " \n"[i == n - 1];
    }
     vector<pair<int,int>>       pair可以换成tuple   (任意多)


求最小 pd数据处理
    memset(f, 0x3f, sizeof(f));
    f[1] = 1;

性能优化 #pragma GCC optimize(2)

优先队列
    priority_queue<Type, Container, Functional>
	top 访问队头元素
	empty 队列是否为空
	size 返回队列内元素个数
	push 插入元素到队尾 (并排序)
	emplace 原地构造一个元素并插入队列
	pop 弹出队头元素
	swap 交换内容

本地测试读入和对比
	#ifdef LOCAL
    freopen("D:/VSCodeField/C_Practice/.input/a.in", "r", stdin);
    freopen("D:/VSCodeField/C_Practice/.input/a.out", "w", stdout);
    #endif
    ios::sync_with_stdio(false);
    cin.tie(0);
	
快读
    template<typename T>void in(T &x) {
    char ch = getchar();bool flag = 0;x = 0;
    while(ch < '0' || ch > '9') flag |= (ch == '-'), ch = getchar();
    while(ch <= '9' && ch >= '0') x = (x << 1) + (x << 3) + ch - '0', ch = getchar();
    if(flag) x = -x;return ;
    }
inline int read(){
int x=0,w=1;
char ch=0;
while(ch!='-'||(ch<'0'&&ch>'9')) ch=getchar();
if(ch=='-') w=-1,ch=getchar();
while(ch>='0'&&ch=<'9') x+=x*10+ch-48,ch=getchar();
return x*w;
}
inline int read()
{
	int ret=0;bool f=0;char c=getchar();
	while(c>'9'||c<'0')f|=(c=='-'),c=getchar();
	while(c>='0'&&c<='9')ret=(ret<<3)+(ret<<1)+(c^48),c=getchar();
	return f?-ret:ret;
}
inline int read(){
	int x=0,f=0;char ch=getchar();
	while(ch>'9'||ch<'0'){if(ch=='-')f=1;ch=getchar();}
	while(ch<='9'&&ch>='0'){x=(x<<3)+(x<<1)+ch-'0';ch=getchar();}
	return f?-x:x;
}	

bfs(s) {
  q = new queue()
  q.push(s), visited[s] = true
  while (!q.empty()) {
    u = q.pop()
    for each edge(u, v) {
      if (!visited[v]) {
        q.push(v)
        visited[v] = true
      }
    }
  }
}



DFS(v) // v 可以是图中的一个顶点，也可以是抽象的概念，如 dp 状态等。
  在 v 上打访问标记
  for u in v 的相邻节点
    if u 没有打过访问标记 then
      DFS(u)
    end
  end
end



动态规划

dp[j] = max(dp[j], dp[j - v[i]] + w[i])

int dp[t]={0};
  for(int i=0;i<m;i++){
      for(int j=t;j>=0;j--){
    if(j-s[i]>=0){
      dp[j] = max(dp[j-s[i]]+v[i],dp[j]);
    }
    }
  }

STRING

重载了赋值运算符 +，当 + 两边是 string/char/char[]/const char* 类型时，可以将这两个变量连接，返回连接后的字符串（string）。
赋值运算符 = 右侧可以是 const string/string/const char*/char*。
访问运算符 [cur] 返回 cur 位置的引用。
访问函数 data()/c_str() 返回一个 const char* 指针，内容与该 string 相同。

容量函数 size() 返回字符串字符个。

find(ch, start = 0) 查找并返回从 start 开始的字符 ch 的位置；rfind(ch) 从末尾开始，查找并返回第一个找到的字符 ch 的位置（皆从  开始）（如果查找不到，返回 ）。

substr(start, len) 可以从字符串的 start（从  开始）截取一个长度为 len 的字符串（缺省 len 时代码截取到字符串末尾）。

append(s) 将 s 添加到字符串末尾。

append(s, pos, n) 将字符串 s 中，从 pos 开始的 n 个字符连接到当前字符串结尾。

replace(pos, n, s) 删除从 pos 开始的 n 个字符，然后在 pos 处插入串 s。

erase(pos, n) 删除从 pos 开始的 n 个字符。

insert(pos, s) 在 pos 位置插入字符串 s。

数转字符串 to_string(int/double/float)

MAP


map<Key, T> yourMap;

map<string, int> mp;

可以直接通过下标访问来进行查询或插入操作。例如 mp["Alan"]=100。
通过向 map 中插入一个类型为 pair<Key, T> 的值可以达到插入元素的目的，例如 mp.insert(pair<string,int>("Alan",100));；

erase(key) 函数会删除键为 key 的 所有 元素。返回值为删除元素的数量。

erase(pos): 删除迭代器为 pos 的元素，要求迭代器必须合法。

erase(first,last): 删除迭代器在  范围内的所有元素。

clear() 函数会清空整个容器。

count(x): 返回容器内键为 x 的元素数量。复杂度为 （关于容器大小对数复杂度，加上匹配个数）。
find(x): 若容器内存在键为 x 的元素，会返回该元素的迭代器；否则返回 end()。

empty(): 返回容器是否为空。

size(): 返回容器内元素个数。

        STL 提供了大约 100 个实现算法的模版函数，基本都包含在 <algorithm> 之中，还有一部分        包含在 <numeric> 和 <functional>。完备的函数列表请 参见参考手册，排序相关的可以参          考 排序内容的对应页面。

find：顺序查找。find(v.begin(), v.end(), value)，其中 value 为需要查找的值。

find_end：逆序查找。find_end(v.begin(), v.end(), value)。

reverse：翻转数组、字符串。reverse(v.begin(), v.end()) 或 reverse(a + begin, a + end)。

unique：去除容器中相邻的重复元素。unique(ForwardIterator first, ForwardIterator last)，返回值为指向 去重后 容器结尾的迭代器，原容器大小不变。与 sort 结合使用可以实现完整容器去重。

random_shuffle：随机地打乱数组。random_shuffle(v.begin(), v.end()) 或 random_shuffle(v + begin, v + end)。

sort：排序。sort(v.begin(), v.end(), cmp) 或 sort(a + begin, a + end, cmp)，其中 end 是排序的数组最后一个元素的后一位，cmp 为自定义的比较函数。

stable_sort：稳定排序，用法同 sort()。

nth_element：按指定范围进行分类，即找出序列中第  大的元素，使其左边均为小于它的数，右边均为大于它的数。nth_element(v.begin(), v.begin() + mid, v.end(), cmp) 或 nth_element(a + begin, a + begin + mid, a + end, cmp)。

binary_search：二分查找。binary_search(v.begin(), v.end(), value)，其中 value 为需要查找的值。

merge：将两个（已排序的）序列 有序合并 到第三个序列的 插入迭代器 上。merge(v1.begin(), v1.end(), v2.begin(), v2.end() ,back_inserter(v3))。

inplace_merge：将两个（已按小于运算符排序的）：[first,middle), [middle,last) 范围 原地合并为一个有序序列。inplace_merge(v.begin(), v.begin() + middle, v.end())。

lower_bound：在一个有序序列中进行二分查找，返回指向第一个 大于等于  的元素的位置的迭代器。如果不存在这样的元素，则返回尾迭代器。lower_bound(v.begin(),v.end(),x)。

upper_bound：在一个有序序列中进行二分查找，返回指向第一个 大于  的元素的位置的迭代器。如果不存在这样的元素，则返回尾迭代器。upper_bound(v.begin(),v.end(),x)。

STL可用库函数

swap（a，b）              交换值

sort（a,a+n,compare）   排序

unique(first,end)                  去重

max_element(first,end)[0]                     返回最大元素

 cout << setprecision(3) << quotient << endl;                          输出两位有效小数

unordered_map<int,int> h;

string.substr(pos,len)     字符串子串

sum = accumulate(array,array+size(array),数据type);  数组求和

快速读入

ios::sync_with_stdio(false), cin.tie(nullptr), cout.tie(nullptr);

读入优化

int read() {
  int x = 0, w = 1;
  char ch = 0;
  while (ch < '0' || ch > '9') {  // ch 不是数字时
    if (ch == '-') w = -1;        // 判断是否为负
    ch = getchar();               // 继续读入
  }
  while (ch >= '0' && ch <= '9') {  // ch 是数字时
    x = x * 10 + (ch - '0');  // 将新读入的数字’加’在 x 的后面
    // x 是 int 类型，char 类型的 ch 和 ’0’ 会被自动转为其对应的
    // ASCII 码，相当于将 ch 转化为对应数字
    // 此处也可以使用 (x<<3)+(x<<1) 的写法来代替 x*10
    ch = getchar();  // 继续读入
  }
  return x * w;  // 数字 * 正负号 = 实际数值
}

二分

while(l<=r){
            int mid = (l+r)>>1;
            if(ck(mid)) l=mid+1;
            else r=mid-1;
}              //l，r都为所求值

while(i<n-1)
        {
            mid=(i+n)/2;
            if(isBadVersion(mid)) n=mid;
            else i=mid;
        }
        if(isBadVersion(i)) return i;
        else return i+1;



								常用代码模板1——基础算法


快速排序算法模板
void quick_sort(int q[], int l, int r)
{
    if (l >= r) return;

    int i = l - 1, j = r + 1, x = q[l + r >> 1];
    while (i < j)
    {
        do i ++ ; while (q[i] < x);
        do j -- ; while (q[j] > x);
        if (i < j) swap(q[i], q[j]);
    }
    quick_sort(q, l, j), quick_sort(q, j + 1, r);
}


归并排序算法模板
void merge_sort(int q[], int l, int r)
{
    if (l >= r) return;

    int mid = l + r >> 1;
    merge_sort(q, l, mid);
    merge_sort(q, mid + 1, r);

    int k = 0, i = l, j = mid + 1;
    while (i <= mid && j <= r)
        if (q[i] <= q[j]) tmp[k ++ ] = q[i ++ ];
        else tmp[k ++ ] = q[j ++ ];

    while (i <= mid) tmp[k ++ ] = q[i ++ ];
    while (j <= r) tmp[k ++ ] = q[j ++ ];

    for (i = l, j = 0; i <= r; i ++, j ++ ) q[i] = tmp[j];
}


整数二分算法模板 
bool check(int x) {/* ... */} // 检查x是否满足某种性质

// 区间[l, r]被划分成[l, mid]和[mid + 1, r]时使用：
int bsearch_1(int l, int r)
{
    while (l < r)
    {
        int mid = l + r >> 1;
        if (check(mid)) r = mid;    // check()判断mid是否满足性质
        else l = mid + 1;
    }
    return l;
}
// 区间[l, r]被划分成[l, mid - 1]和[mid, r]时使用：
int bsearch_2(int l, int r)
{
    while (l < r)
    {
        int mid = l + r + 1 >> 1;
        if (check(mid)) l = mid;
        else r = mid - 1;
    }
    return l;
}


浮点数二分算法模板 
bool check(double x) {/* ... */} // 检查x是否满足某种性质

double bsearch_3(double l, double r)
{
    const double eps = 1e-6;   // eps 表示精度，取决于题目对精度的要求
    while (r - l > eps)
    {
        double mid = (l + r) / 2;
        if (check(mid)) r = mid;
        else l = mid;
    }
    return l;
}


高精度加法
// C = A + B, A >= 0, B >= 0
vector<int> add(vector<int> &A, vector<int> &B)
{
    if (A.size() < B.size()) return add(B, A);

    vector<int> C;
    int t = 0;
    for (int i = 0; i < A.size(); i ++ )
    {
        t += A[i];
        if (i < B.size()) t += B[i];
        C.push_back(t % 10);
        t /= 10;
    }

    if (t) C.push_back(t);
    return C;
}


高精度减法
// C = A - B, 满足A >= B, A >= 0, B >= 0
vector<int> sub(vector<int> &A, vector<int> &B)
{
    vector<int> C;
    for (int i = 0, t = 0; i < A.size(); i ++ )
    {
        t = A[i] - t;
        if (i < B.size()) t -= B[i];
        C.push_back((t + 10) % 10);
        if (t < 0) t = 1;
        else t = 0;
    }

    while (C.size() > 1 && C.back() == 0) C.pop_back();
    return C;
}


高精度乘低精度 
// C = A * b, A >= 0, b >= 0
vector<int> mul(vector<int> &A, int b)
{
    vector<int> C;

    int t = 0;
    for (int i = 0; i < A.size() || t; i ++ )
    {
        if (i < A.size()) t += A[i] * b;
        C.push_back(t % 10);
        t /= 10;
    }

    while (C.size() > 1 && C.back() == 0) C.pop_back();

    return C;
}


高精度除以低精度
// A / b = C ... r, A >= 0, b > 0
vector<int> div(vector<int> &A, int b, int &r)
{
    vector<int> C;
    r = 0;
    for (int i = A.size() - 1; i >= 0; i -- )
    {
        r = r * 10 + A[i];
        C.push_back(r / b);
        r %= b;
    }
    reverse(C.begin(), C.end());
    while (C.size() > 1 && C.back() == 0) C.pop_back();
    return C;
}


二维差分
给以(x1, y1)为左上角，(x2, y2)为右下角的子矩阵中的所有元素加上c：
S[x1, y1] += c, S[x2 + 1, y1] -= c, S[x1, y2 + 1] -= c, S[x2 + 1, y2 + 1] += c


位运算
for (int i = 0, j = 0; i < n; i ++ )
{
    while (j < i && check(i, j)) j ++ ;

    // 具体问题的逻辑
}
常见问题分类：
    (1) 对于一个序列，用两个指针维护一段区间
    (2) 对于两个序列，维护某种次序，比如归并排序中合并两个有序序列的操作
	
	
离散化
vector<int> alls; // 存储所有待离散化的值
sort(alls.begin(), alls.end()); // 将所有值排序 greater<int>()
alls.erase(unique(alls.begin(), alls.end()), alls.end());   // 去掉重复元素

// 二分求出x对应的离散化的值
int find(int x) // 找到第一个大于等于x的位置
{
    int l = 0, r = alls.size() - 1;
    while (l < r)
    {
        int mid = l + r >> 1;
        if (alls[mid] >= x) r = mid;
        else l = mid + 1;
    }
    return r + 1; // 映射到1, 2, ...n
}


区间合并
void merge(vector<PII> &segs)
{
    vector<PII> res;

    sort(segs.begin(), segs.end());

    int st = -2e9, ed = -2e9;
    for (auto seg : segs)
        if (ed < seg.first)
        {
            if (st != -2e9) res.push_back({st, ed});
            st = seg.first, ed = seg.second;
        }
        else ed = max(ed, seg.second);

    if (st != -2e9) res.push_back({st, ed});

    segs = res;
}



									常用代码模板2——数据结构
									
单链表 
// head存储链表头，e[]存储节点的值，ne[]存储节点的next指针，idx表示当前用到了哪个节点
int head, e[N], ne[N], idx;

// 初始化
void init()
{
    head = -1;
    idx = 0;
}

// 在链表头插入一个数a
void insert(int a)
{
    e[idx] = a, ne[idx] = head, head = idx ++ ;
}

// 将头结点删除，需要保证头结点存在
void remove()
{
    head = ne[head];
}


双链表
// e[]表示节点的值，l[]表示节点的左指针，r[]表示节点的右指针，idx表示当前用到了哪个节点
int e[N], l[N], r[N], idx;

// 初始化
void init()
{
    //0是左端点，1是右端点
    r[0] = 1, l[1] = 0;
    idx = 2;
}

// 在节点a的右边插入一个数x
void insert(int a, int x)
{
    e[idx] = x;
    l[idx] = a, r[idx] = r[a];
    l[r[a]] = idx, r[a] = idx ++ ;
}

// 删除节点a
void remove(int a)
{
    l[r[a]] = l[a];
    r[l[a]] = r[a];
}


栈
// tt表示栈顶
int stk[N], tt = 0;

// 向栈顶插入一个数
stk[ ++ tt] = x;

// 从栈顶弹出一个数
tt -- ;

// 栈顶的值
stk[tt];

// 判断栈是否为空
if (tt > 0)
{

}



	队列
	
1. 普通队列：
// hh 表示队头，tt表示队尾
int q[N], hh = 0, tt = -1;

// 向队尾插入一个数
q[ ++ tt] = x;

// 从队头弹出一个数
hh ++ ;

// 队头的值
q[hh];

// 判断队列是否为空
if (hh <= tt)
{

}

2. 循环队列
// hh 表示队头，tt表示队尾的后一个位置
int q[N], hh = 0, tt = 0;

// 向队尾插入一个数
q[tt ++ ] = x;
if (tt == N) tt = 0;

// 从队头弹出一个数
hh ++ ;
if (hh == N) hh = 0;

// 队头的值
q[hh];

// 判断队列是否为空
if (hh != tt)
{

}


单调栈
常见模型：找出每个数左边离它最近的比它大/小的数
int tt = 0;
for (int i = 1; i <= n; i ++ )
{
    while (tt && check(stk[tt], i)) tt -- ;
    stk[ ++ tt] = i;
}


单调队列
常见模型：找出滑动窗口中的最大值/最小值
int hh = 0, tt = -1;
for (int i = 0; i < n; i ++ )
{
    while (hh <= tt && check_out(q[hh])) hh ++ ;  // 判断队头是否滑出窗口
    while (hh <= tt && check(q[tt], i)) tt -- ;
    q[ ++ tt] = i;
}


KMP算法
int strStr(string haystack, string needle) {
	int n = haystack.size(), m = needle.size();
	if (m == 0) {
		return 0;
	}
	vector<int> pi(m);
	for (int i = 1, j = 0; i < m; i++) {
		while (j > 0 && needle[i] != needle[j]) {
			j = pi[j - 1];
		}
		if (needle[i] == needle[j]) {
			j++;
		}
		pi[i] = j;
	}
	for (int i = 0, j = 0; i < n; i++) {
		while (j > 0 && haystack[i] != needle[j]) {
			j = pi[j - 1];
		}
		if (haystack[i] == needle[j]) {
			j++;
		}
		if (j == m) {
			return i - m + 1;
		}
	}
	return -1;
}


sunday算法
int indexShift(const string s,const char ch) {
	for (int k1(0); k1 < s.length(); ++k1) {
		if (ch == s[k1]) return -k1;
	}
	return 1;
}

int sunday(const string s1, const string s2) {
	int ret=0;
	int sl1(s1.length()), sl2(s2.length());
	if (!(sl1 && sl2))return ret;
	for (int k1(0), k2(0); k1 <= sl1 - sl2;) {
		if (s1[k1] == s2[k2]) ++k1, ++k2;
		else {
			k1 += sl2 - k2;
			k1 += k1 < sl1 ? indexShift(s2, s1[k1]) : 0;
			k2 = 0;
		}
		if (k2 == sl2) ret++, k1 -= k2 - 1, k2 = 0;
	}
	return ret;
}


Trie树
int son[N][26], cnt[N], idx;
// 0号点既是根节点，又是空节点
// son[][]存储树中每个节点的子节点
// cnt[]存储以每个节点结尾的单词数量

// 插入一个字符串
void insert(char *str)
{
    int p = 0;
    for (int i = 0; str[i]; i ++ )
    {
        int u = str[i] - 'a';
        if (!son[p][u]) son[p][u] = ++ idx;
        p = son[p][u];
    }
    cnt[p] ++ ;
}

// 查询字符串出现的次数
int query(char *str)
{
    int p = 0;
    for (int i = 0; str[i]; i ++ )
    {
        int u = str[i] - 'a';
        if (!son[p][u]) return 0;
        p = son[p][u];
    }
    return cnt[p];
}


并查集 
(1)朴素并查集：

int p[N]; //存储每个点的祖宗节点

// 返回x的祖宗节点
int find(int x)
{
	if (p[x] != x) p[x] = find(p[x]);
	return p[x];
}

// 初始化，假定节点编号是1~n
for (int i = 1; i <= n; i ++ ) p[i] = i;

// 合并a和b所在的两个集合：
p[find(a)] = find(b);


(2)维护size的并查集：

int p[N], size[N];
//p[]存储每个点的祖宗节点, size[]只有祖宗节点的有意义，表示祖宗节点所在集合中的点的数量

// 返回x的祖宗节点
int find(int x)
{
	if (p[x] != x) p[x] = find(p[x]);
	return p[x];
}

// 初始化，假定节点编号是1~n
for (int i = 1; i <= n; i ++ )
{
	p[i] = i;
	size[i] = 1;
}

// 合并a和b所在的两个集合：
size[find(b)] += size[find(a)];
p[find(a)] = find(b);


(3)维护到祖宗节点距离的并查集：

int p[N], d[N];
//p[]存储每个点的祖宗节点, d[x]存储x到p[x]的距离

// 返回x的祖宗节点
int find(int x)
{
	if (p[x] != x)
	{
		int u = find(p[x]);
		d[x] += d[p[x]];
		p[x] = u;
	}
	return p[x];
}

// 初始化，假定节点编号是1~n
for (int i = 1; i <= n; i ++ )
{
	p[i] = i;
	d[i] = 0;
}

// 合并a和b所在的两个集合：
p[find(a)] = find(b);
d[find(a)] = distance; // 根据具体问题，初始化find(a)的偏移量


堆
// h[N]存储堆中的值, h[1]是堆顶，x的左儿子是2x, 右儿子是2x + 1
// ph[k]存储第k个插入的点在堆中的位置
// hp[k]存储堆中下标是k的点是第几个插入的
int h[N], ph[N], hp[N], size;

// 交换两个点，及其映射关系
void heap_swap(int a, int b)
{
    swap(ph[hp[a]],ph[hp[b]]);
    swap(hp[a], hp[b]);
    swap(h[a], h[b]);
}

void down(int u)
{
    int t = u;
    if (u * 2 <= size && h[u * 2] < h[t]) t = u * 2;
    if (u * 2 + 1 <= size && h[u * 2 + 1] < h[t]) t = u * 2 + 1;
    if (u != t)
    {
        heap_swap(u, t);
        down(t);
    }
}

void up(int u)
{
    while (u / 2 && h[u] < h[u / 2])
    {
        heap_swap(u, u / 2);
        u >>= 1;
    }
}

// O(n)建堆
for (int i = n / 2; i; i -- ) down(i);


一般哈希

(1) 拉链法
int h[N], e[N], ne[N], idx;

// 向哈希表中插入一个数
void insert(int x)
{
	int k = (x % N + N) % N;
	e[idx] = x;
	ne[idx] = h[k];
	h[k] = idx ++ ;
}

// 在哈希表中查询某个数是否存在
bool find(int x)
{
	int k = (x % N + N) % N;
	for (int i = h[k]; i != -1; i = ne[i])
		if (e[i] == x)
			return true;

	return false;
}

(2) 开放寻址法
int h[N];

// 如果x在哈希表中，返回x的下标；如果x不在哈希表中，返回x应该插入的位置
int find(int x)
{
	int t = (x % N + N) % N;
	while (h[t] != null && h[t] != x)
	{
		t ++ ;
		if (t == N) t = 0;
	}
	return t;
}


字符串哈希 
核心思想：将字符串看成P进制数，P的经验值是131或13331，取这两个值的冲突概率低
小技巧：取模的数用2^64，这样直接用unsigned long long存储，溢出的结果就是取模的结果

typedef unsigned long long ULL;
ULL h[N], p[N]; // h[k]存储字符串前k个字母的哈希值, p[k]存储 P^k mod 2^64

// 初始化
p[0] = 1;
for (int i = 1; i <= n; i ++ )
{
    h[i] = h[i - 1] * P + str[i];
    p[i] = p[i - 1] * P;
}

// 计算子串 str[l ~ r] 的哈希值
ULL get(int l, int r)
{
    return h[r] - h[l - 1] * p[r - l + 1];
}

												C++ STL简介
						

		vector, 变长数组，倍增的思想
			size()  返回元素个数
			empty()  返回是否为空
			clear()  清空
			front()/back()  //首、尾
			push_back()/pop_back()
			begin()/end()
			[]
			支持比较运算，按字典序

		pair<int, int>
			first, 第一个元素
			second, 第二个元素
			支持比较运算，以first为第一关键字，以second为第二关键字（字典序）

		string，字符串
			size()/length()  返回字符串长度
			empty()
			clear()
			substr(起始下标，(子串长度))  返回子串
			c_str()  返回字符串所在字符数组的起始地址

		queue, 队列
			size()
			empty()
			push()  向队尾插入一个元素
			front()  返回队头元素
			back()  返回队尾元素
			pop()  弹出队头元素

		priority_queue, 优先队列，默认是大根堆
			size()
			empty()
			push()  插入一个元素
			top()  返回堆顶元素
			pop()  弹出堆顶元素
			定义成小根堆的方式：priority_queue<int, vector<int>, greater<int>> q;

		stack, 栈
			size()
			empty()
			push()  向栈顶插入一个元素
			top()  返回栈顶元素
			pop()  弹出栈顶元素

		deque, 双端队列
			size()
			empty()
			clear()
			front()/back()
			push_back()/pop_back()
			push_front()/pop_front()
			begin()/end()
			[]

		set, map, multiset, multimap, 基于平衡二叉树（红黑树），动态维护有序序列
			size()
			empty()
			clear()
			begin()/end()
			++, -- 返回前驱和后继，时间复杂度 O(logn)

			set/multiset
				insert()  插入一个数
				find()  查找一个数
				count()  返回某一个数的个数
				erase()
					(1) 输入是一个数x，删除所有x   O(k + logn)
					(2) 输入一个迭代器，删除这个迭代器
				lower_bound()/upper_bound()
					lower_bound(x)  返回大于等于x的最小的数的迭代器
					upper_bound(x)  返回大于x的最小的数的迭代器
			map/multimap
				insert()  插入的数是一个pair
				erase()  输入的参数是pair或者迭代器
				find()
				[]  注意multimap不支持此操作。 时间复杂度是 O(logn)
				lower_bound()/upper_bound()

		unordered_set, unordered_map, unordered_multiset, unordered_multimap, 哈希表
			和上面类似，增删改查的时间复杂度是 O(1)
			不支持 lower_bound()/upper_bound()， 迭代器的++，--

		bitset, 圧位
			bitset<10000> s;
			~, &, |, ^
			>>, <<
			==, !=
			[]

			count()  返回有多少个1

			any()  判断是否至少有一个1
			none()  判断是否全为0

			set()  把所有位置成1
			set(k, v)  将第k位变成v
			reset()  把所有位变成0
			flip()  等价于~
			flip(k) 把第k位取反
	




									常用代码模板3——搜索与图论
									

树与图的存储
树是一种特殊的图，与图的存储方式相同。
对于无向图中的边ab，存储两条有向边a->b, b->a。
因此我们可以只考虑有向图的存储。

(1) 邻接矩阵：g[a][b] 存储边a->b

(2) 邻接表：	
								
// 对于每个点k，开一个单链表，存储k所有可以走到的点。h[k]存储这个单链表的头结点
int h[N], e[N], ne[N], idx;

// 添加一条边a->b
void add(int a, int b)
{
    e[idx] = b, ne[idx] = h[a], h[a] = idx ++ ;
}

// 初始化
idx = 0;
memset(h, -1, sizeof h);


树与图的遍历
	时间复杂度 O(n+m), n 表示点数，m 表示边数
	
(1) 深度优先遍历
int dfs(int u)
{
    st[u] = true; // st[u] 表示点u已经被遍历过

    for (int i = h[u]; i != -1; i = ne[i])
    {
        int j = e[i];
        if (!st[j]) dfs(j);
    }
}

(2) 宽度优先遍历
queue<int> q;
st[1] = true; // 表示1号点已经被遍历过
q.push(1);

while (q.size())
{
    int t = q.front();
    q.pop();

    for (int i = h[t]; i != -1; i = ne[i])
    {
        int j = e[i];
        if (!st[j])
        {
            st[j] = true; // 表示点j已经被遍历过
            q.push(j);
        }
    }
}


拓扑排序
bool topsort()
{
    int hh = 0, tt = -1;

    // d[i] 存储点i的入度
    for (int i = 1; i <= n; i ++ )
        if (!d[i])
            q[ ++ tt] = i;

    while (hh <= tt)
    {
        int t = q[hh ++ ];

        for (int i = h[t]; i != -1; i = ne[i])
        {
            int j = e[i];
            if (-- d[j] == 0)
                q[ ++ tt] = j;
        }
    }

    // 如果所有点都入队了，说明存在拓扑序列；否则不存在拓扑序列。
    return tt == n - 1;
}


堆优化版dijkstra O(mlogn)
typedef pair<int, int> PII;

int n;      // 点的数量
int h[N], w[N], e[N], ne[N], idx;       // 邻接表存储所有边
int dist[N];        // 存储所有点到1号点的距离
bool st[N];     // 存储每个点的最短距离是否已确定

// 求1号点到n号点的最短距离，如果不存在，则返回-1
int dijkstra()
{
    memset(dist, 0x3f, sizeof dist);
    dist[1] = 0;
    priority_queue<PII, vector<PII>, greater<PII>> heap;
    heap.push({0, 1});      // first存储距离，second存储节点编号

    while (heap.size())
    {
        auto t = heap.top();
        heap.pop();

        int ver = t.second, distance = t.first;

        if (st[ver]) continue;
        st[ver] = true;

        for (int i = h[ver]; i != -1; i = ne[i])
        {
            int j = e[i];
            if (dist[j] > distance + w[i])
            {
                dist[j] = distance + w[i];
                heap.push({dist[j], j});
            }
        }
    }

    if (dist[n] == 0x3f3f3f3f) return -1;
    return dist[n];
}


Bellman-Ford算法O(nm)
int n, m;       // n表示点数，m表示边数
int dist[N];        // dist[x]存储1到x的最短路距离

struct Edge     // 边，a表示出点，b表示入点，w表示边的权重
{
    int a, b, w;
}edges[M];

// 求1到n的最短路距离，如果无法从1走到n，则返回-1。
int bellman_ford()
{
    memset(dist, 0x3f, sizeof dist);
    dist[1] = 0;

    // 如果第n次迭代仍然会松弛三角不等式，就说明存在一条长度是n+1的最短路径，由抽屉原理，路径中至少存在两个相同的点，说明图中存在负权回路。
    for (int i = 0; i < n; i ++ )
    {
        for (int j = 0; j < m; j ++ )
        {
            int a = edges[j].a, b = edges[j].b, w = edges[j].w;
            if (dist[b] > dist[a] + w)
                dist[b] = dist[a] + w;
        }
    }

    if (dist[n] > 0x3f3f3f3f / 2) return -1;
    return dist[n];
}


spfa 算法（队列优化的Bellman-Ford算法）
int n;      // 总点数
int h[N], w[N], e[N], ne[N], idx;       // 邻接表存储所有边
int dist[N];        // 存储每个点到1号点的最短距离
bool st[N];     // 存储每个点是否在队列中

// 求1号点到n号点的最短路距离，如果从1号点无法走到n号点则返回-1
int spfa()
{
    memset(dist, 0x3f, sizeof dist);
    dist[1] = 0;

    queue<int> q;
    q.push(1);
    st[1] = true;

    while (q.size())
    {
        auto t = q.front();
        q.pop();

        st[t] = false;

        for (int i = h[t]; i != -1; i = ne[i])
        {
            int j = e[i];
            if (dist[j] > dist[t] + w[i])
            {
                dist[j] = dist[t] + w[i];
                if (!st[j])     // 如果队列中已存在j，则不需要将j重复插入
                {
                    q.push(j);
                    st[j] = true;
                }
            }
        }
    }

    if (dist[n] == 0x3f3f3f3f) return -1;
    return dist[n];
}


floyd算法
初始化：
    for (int i = 1; i <= n; i ++ )
        for (int j = 1; j <= n; j ++ )
            if (i == j) d[i][j] = 0;
            else d[i][j] = INF;

// 算法结束后，d[a][b]表示a到b的最短距离
void floyd()
{
    for (int k = 1; k <= n; k ++ )
        for (int i = 1; i <= n; i ++ )
            for (int j = 1; j <= n; j ++ )
                d[i][j] = min(d[i][j], d[i][k] + d[k][j]);
}


朴素版prim算法 O(n^2+m)
int n;      // n表示点数
int g[N][N];        // 邻接矩阵，存储所有边
int dist[N];        // 存储其他点到当前最小生成树的距离
bool st[N];     // 存储每个点是否已经在生成树中


// 如果图不连通，则返回INF(值是0x3f3f3f3f), 否则返回最小生成树的树边权重之和
int prim()
{
    memset(dist, 0x3f, sizeof dist);

    int res = 0;
    for (int i = 0; i < n; i ++ )
    {
        int t = -1;
        for (int j = 1; j <= n; j ++ )
            if (!st[j] && (t == -1 || dist[t] > dist[j]))
                t = j;

        if (i && dist[t] == INF) return INF;

        if (i) res += dist[t];
        st[t] = true;

        for (int j = 1; j <= n; j ++ ) dist[j] = min(dist[j], g[t][j]);
    }

    return res;
}


Kruskal算法O (mlogm)
int n, m;       // n是点数，m是边数
int p[N];       // 并查集的父节点数组

struct Edge     // 存储边
{
    int a, b, w;

    bool operator< (const Edge &W)const
    {
        return w < W.w;
    }
}edges[M];

int find(int x)     // 并查集核心操作
{
    if (p[x] != x) p[x] = find(p[x]);
    return p[x];
}

int kruskal()
{
    sort(edges, edges + m);

    for (int i = 1; i <= n; i ++ ) p[i] = i;    // 初始化并查集

    int res = 0, cnt = 0;
    for (int i = 0; i < m; i ++ )
    {
        int a = edges[i].a, b = edges[i].b, w = edges[i].w;

        a = find(a), b = find(b);
        if (a != b)     // 如果两个连通块不连通，则将这两个连通块合并
        {
            p[a] = b;
            res += w;
            cnt ++ ;
        }
    }

    if (cnt < n - 1) return INF;
    return res;
}


染色法判别二分图 O(n+m)
int n;      // n表示点数
int h[N], e[M], ne[M], idx;     // 邻接表存储图
int color[N];       // 表示每个点的颜色，-1表示未染色，0表示白色，1表示黑色

// 参数：u表示当前节点，c表示当前点的颜色
bool dfs(int u, int c)
{
    color[u] = c;
    for (int i = h[u]; i != -1; i = ne[i])
    {
        int j = e[i];
        if (color[j] == -1)
        {
            if (!dfs(j, !c)) return false;
        }
        else if (color[j] == c) return false;
    }

    return true;
}

bool check()
{
    memset(color, -1, sizeof color);
    bool flag = true;
    for (int i = 1; i <= n; i ++ )
        if (color[i] == -1)
            if (!dfs(i, 0))
            {
                flag = false;
                break;
            }
    return flag;
}


匈牙利算法O(nm) 二分图最大匹配
int n1, n2;     // n1表示第一个集合中的点数，n2表示第二个集合中的点数
int h[N], e[M], ne[M], idx;     // 邻接表存储所有边，匈牙利算法中只会用到从第一个集合指向第二个集合的边，所以这里只用存一个方向的边
int match[N];       // 存储第二个集合中的每个点当前匹配的第一个集合中的点是哪个
bool st[N];     // 表示第二个集合中的每个点是否已经被遍历过

bool find(int x)
{
    for (int i = h[x]; i != -1; i = ne[i])
    {
        int j = e[i];
        if (!st[j])
        {
            st[j] = true;
            if (match[j] == 0 || find(match[j]))
            {
                match[j] = x;
                return true;
            }
        }
    }

    return false;
}

// 求最大匹配数，依次枚举第一个集合中的每个点能否匹配第二个集合中的点
int res = 0;
for (int i = 1; i <= n1; i ++ )
{
    memset(st, false, sizeof st);
    if (find(i)) res ++ ;
}




											常用代码模板4——数学知识	




试除法判定质数
bool is_prime(int x)
{
    if (x < 2) return false;
    for (int i = 2; i <= x / i; i ++ )
        if (x % i == 0)
            return false;
    return true;
}


试除法分解质因数
void divide(int x)
{
    for (int i = 2; i <= x / i; i ++ )
        if (x % i == 0)
        {
            int s = 0;
            while (x % i == 0) x /= i, s ++ ;
            cout << i << ' ' << s << endl;
        }
    if (x > 1) cout << x << ' ' << 1 << endl;
    cout << endl;
}


线性筛法求素数
int primes[N], cnt;     // primes[]存储所有素数
bool st[N];         // st[x]存储x是否被筛掉

void get_primes(int n)
{
    for (int i = 2; i <= n; i ++ )
    {
        if (!st[i]) primes[cnt ++ ] = i;
        for (int j = 0; primes[j] <= n / i; j ++ )
        {
            st[primes[j] * i] = true;
            if (i % primes[j] == 0) break;
        }
    }
}


试除法求所有约数 
vector<int> get_divisors(int x)
{
    vector<int> res;
    for (int i = 1; i <= x / i; i ++ )
        if (x % i == 0)
        {
            res.push_back(i);
            if (i != x / i) res.push_back(x / i);
        }
    sort(res.begin(), res.end());
    return res;
}


约数个数和约数之和
如果 N = p1^c1 * p2^c2 * ... *pk^ck
约数个数： (c1 + 1) * (c2 + 1) * ... * (ck + 1)
约数之和： (p1^0 + p1^1 + ... + p1^c1) * ... * (pk^0 + pk^1 + ... + pk^ck)


欧几里得算法（公约数）
int gcd(int a, int b)
{
    return b ? gcd(b, a % b) : a;
}


求欧拉函数
int phi(int x)
{
    int res = x;
    for (int i = 2; i <= x / i; i ++ )
        if (x % i == 0)
        {
            res = res / i * (i - 1);
            while (x % i == 0) x /= i;
        }
    if (x > 1) res = res / x * (x - 1);

    return res;
}


筛法求欧拉函数 
int primes[N], cnt;     // primes[]存储所有素数
int eu[N];           // 存储每个数的欧拉函数
bool st[N];         // st[x]存储x是否被筛掉


void get_eus(int n)
{
    eu[1] = 1;
    for (int i = 2; i <= n; i ++ )
    {
        if (!st[i])
        {
            primes[cnt ++ ] = i;
            eu[i] = i - 1;
        }
        for (int j = 0; primes[j] <= n / i; j ++ )
        {
            int t = primes[j] * i;
            st[t] = true;
            if (i % primes[j] == 0)
            {
                eu[t] = eu[i] * primes[j];
                break;
            }
            eu[t] = eu[i] * (primes[j] - 1);
        }
    }
}


快速幂
求 m^k mod p，时间复杂度 O(logk)。

int qmi(int m, int k, int p)
{
    int res = 1 % p, t = m;
    while (k)
    {
        if (k&1) res = res * t % p;
        t = t * t % p;
        k >>= 1;
    }
    return res;
}


扩展欧几里得算法
// 求x, y，使得ax + by = gcd(a, b)
int exgcd(int a, int b, int &x, int &y)
{
    if (!b)
    {
        x = 1; y = 0;
        return a;
    }
    int d = exgcd(b, a % b, y, x);
    y -= (a/b) * x;
    return d;
}


高斯消元
// a[N][N]是增广矩阵
int gauss()
{
    int c, r;
    for (c = 0, r = 0; c < n; c ++ )
    {
        int t = r;
        for (int i = r; i < n; i ++ )   // 找到绝对值最大的行
            if (fabs(a[i][c]) > fabs(a[t][c]))
                t = i;

        if (fabs(a[t][c]) < eps) continue;

        for (int i = c; i <= n; i ++ ) swap(a[t][i], a[r][i]);      // 将绝对值最大的行换到最顶端
        for (int i = n; i >= c; i -- ) a[r][i] /= a[r][c];      // 将当前行的首位变成1
        for (int i = r + 1; i < n; i ++ )       // 用当前行将下面所有的列消成0
            if (fabs(a[i][c]) > eps)
                for (int j = n; j >= c; j -- )
                    a[i][j] -= a[r][j] * a[i][c];

        r ++ ;
    }

    if (r < n)
    {
        for (int i = r; i < n; i ++ )
            if (fabs(a[i][n]) > eps)
                return 2; // 无解
        return 1; // 有无穷多组解
    }

    for (int i = n - 1; i >= 0; i -- )
        for (int j = i + 1; j < n; j ++ )
            a[i][n] -= a[i][j] * a[j][n];

    return 0; // 有唯一解
}


递归法求组合数
// c[a][b] 表示从a个苹果中选b个的方案数
for (int i = 0; i < N; i ++ )
    for (int j = 0; j <= i; j ++ )
        if (!j) c[i][j] = 1;
        else c[i][j] = (c[i - 1][j] + c[i - 1][j - 1]) % mod;
		
		
通过预处理逆元的方式求组合数
首先预处理出所有阶乘取模的余数fact[N]，以及所有阶乘取模的逆元infact[N]
如果取模的数是质数，可以用费马小定理求逆元
int qmi(int a, int k, int p)    // 快速幂模板
{
    int res = 1;
    while (k)
    {
        if (k & 1) res = (LL)res * a % p;
        a = (LL)a * a % p;
        k >>= 1;
    }
    return res;
}

// 预处理阶乘的余数和阶乘逆元的余数
fact[0] = infact[0] = 1;
for (int i = 1; i < N; i ++ )
{
    fact[i] = (LL)fact[i - 1] * i % mod;
    infact[i] = (LL)infact[i - 1] * qmi(i, mod - 2, mod) % mod;
}


Lucas定理
若p是质数，则对于任意整数 1 <= m <= n，有：
    C(n, m) = C(n % p, m % p) * C(n / p, m / p) (mod p)

int qmi(int a, int k, int p)  // 快速幂模板
{
    int res = 1 % p;
    while (k)
    {
        if (k & 1) res = (LL)res * a % p;
        a = (LL)a * a % p;
        k >>= 1;
    }
    return res;
}

int C(int a, int b, int p)  // 通过定理求组合数C(a, b)
{
    if (a < b) return 0;

    LL x = 1, y = 1;  // x是分子，y是分母
    for (int i = a, j = 1; j <= b; i --, j ++ )
    {
        x = (LL)x * i % p;
        y = (LL) y * j % p;
    }

    return x * (LL)qmi(y, p - 2, p) % p;
}

int lucas(LL a, LL b, int p)
{
    if (a < p && b < p) return C(a, b, p);
    return (LL)C(a % p, b % p, p) * lucas(a / p, b / p, p) % p;
}


分解质因数法求组合数 
当我们需要求出组合数的真实值，而非对某个数的余数时，分解质因数的方式比较好用：
    1. 筛法求出范围内的所有质数
    2. 通过 C(a, b) = a! / b! / (a - b)! 这个公式求出每个质因子的次数。 n! 中p的次数是 n / p + n / p^2 + n / p^3 + ...
    3. 用高精度乘法将所有质因子相乘

int primes[N], cnt;     // 存储所有质数
int sum[N];     // 存储每个质数的次数
bool st[N];     // 存储每个数是否已被筛掉


void get_primes(int n)      // 线性筛法求素数
{
    for (int i = 2; i <= n; i ++ )
    {
        if (!st[i]) primes[cnt ++ ] = i;
        for (int j = 0; primes[j] <= n / i; j ++ )
        {
            st[primes[j] * i] = true;
            if (i % primes[j] == 0) break;
        }
    }
}


int get(int n, int p)       // 求n！中的次数
{
    int res = 0;
    while (n)
    {
        res += n / p;
        n /= p;
    }
    return res;
}


vector<int> mul(vector<int> a, int b)       // 高精度乘低精度模板
{
    vector<int> c;
    int t = 0;
    for (int i = 0; i < a.size(); i ++ )
    {
        t += a[i] * b;
        c.push_back(t % 10);
        t /= 10;
    }

    while (t)
    {
        c.push_back(t % 10);
        t /= 10;
    }

    return c;
}

get_primes(a);  // 预处理范围内的所有质数

for (int i = 0; i < cnt; i ++ )     // 求每个质因数的次数
{
    int p = primes[i];
    sum[i] = get(a, p) - get(b, p) - get(a - b, p);
}

vector<int> res;
res.push_back(1);

for (int i = 0; i < cnt; i ++ )     // 用高精度乘法将所有质因子相乘
    for (int j = 0; j < sum[i]; j ++ )
        res = mul(res, primes[i]);
		

卡特兰数
给定n个0和n个1，它们按照某种顺序排成长度为2n的序列，满足任意前缀中0的个数都不少于1的个数的序列的数量为： Cat(n) = C(2n, n) / (n + 1)


NIM游戏
给定N堆物品，第i堆物品有Ai个。两名玩家轮流行动，每次可以任选一堆，取走任意多个物品，可把一堆取光，但不能不取。取走最后一件物品者获胜。两人都采取最优策略，问先手是否必胜。

我们把这种游戏称为NIM博弈。把游戏过程中面临的状态称为局面。整局游戏第一个行动的称为先手，第二个行动的称为后手。若在某一局面下无论采取何种行动，都会输掉游戏，则称该局面必败。
所谓采取最优策略是指，若在某一局面下存在某种行动，使得行动后对面面临必败局面，则优先采取该行动。同时，这样的局面被称为必胜。我们讨论的博弈问题一般都只考虑理想情况，即两人均无失误，都采取最优策略行动时游戏的结果。
NIM博弈不存在平局，只有先手必胜和先手必败两种情况。

定理： NIM博弈先手必胜，当且仅当 A1 ^ A2 ^ … ^ An != 0


公平组合游戏ICG
	若一个游戏满足：
		1、由两名玩家交替行动；
		2、在游戏进程的任意时刻，可以执行的合法行动与轮到哪名玩家无关；
		3、不能行动的玩家判负；
	则称该游戏为一个公平组合游戏。
	NIM博弈属于公平组合游戏，但城建的棋类游戏，比如围棋，就不是公平组合游戏。因为围棋交战双方分别只能落黑子和白子，胜负判定也比较复杂，不满足条件2和条件3
	

有向图游戏
给定一个有向无环图，图中有一个唯一的起点，在起点上放有一枚棋子。两名玩家交替地把这枚棋子沿有向边进行移动，每次可以移动一步，无法移动者判负。该游戏被称为有向图游戏。
任何一个公平组合游戏都可以转化为有向图游戏。具体方法是，把每个局面看成图中的一个节点，并且从每个局面向沿着合法行动能够到达的下一个局面连有向边。


Mex运算
设S表示一个非负整数集合。定义mex(S)为求出不属于集合S的最小非负整数的运算，即：
mex(S) = min{x}, x属于自然数，且x不属于S


SG函数
在有向图游戏中，对于每个节点x，设从x出发共有k条有向边，分别到达节点y1, y2, …, yk，定义SG(x)为x的后继节点y1, y2, …, yk 的SG函数值构成的集合再执行mex(S)运算的结果，即：
SG(x) = mex({SG(y1), SG(y2), …, SG(yk)})
特别地，整个有向图游戏G的SG函数值被定义为有向图游戏起点s的SG函数值，即SG(G) = SG(s)。


有向图游戏的和
设G1, G2, …, Gm 是m个有向图游戏。定义有向图游戏G，它的行动规则是任选某个有向图游戏Gi，并在Gi上行动一步。G被称为有向图游戏G1, G2, …, Gm的和。
有向图游戏的和的SG函数值等于它包含的各个子游戏SG函数值的异或和，即：
SG(G) = SG(G1) ^ SG(G2) ^ … ^ SG(Gm)


定理
有向图游戏的某个局面必胜，当且仅当该局面对应节点的SG函数值大于0。
有向图游戏的某个局面必败，当且仅当该局面对应节点的SG函数值等于0。